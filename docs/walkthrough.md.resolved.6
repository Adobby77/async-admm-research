# Walkthrough - Fully Distributed Async ADMM (Ring Topology)

I have implemented the **True Distributed P2P** version of the algorithm, moving away from the centralized simulator.

## Implementation Changes (Distributed Logic)
- **Topology**: Undirected Ring (Connection $i \leftrightarrow i+1$).
- **Local Optimization**: Agent $i$ optimizes not just $x_i$, but also *proposals* for neighbors $x_{i-1}, x_{i+1}$.
- **Message Passing**:
    - **L2G**: Agent $i \to$ Neighbors (Proposals $x_j^i$).
    - **G2L**: Agent $j \to$ Predecessors (Consensus $z_j$).
- **Consensus**: $z_j$ is computed locally by Agent $j$ by averaging received proposals.

## Results: Ring Topology (Stress Test)

6 Agents, Hexagon Formation, Max Delay 5, Prob 90%.

![Distributed ADMM Results](/home/sriv/.gemini/antigravity/brain/0a70ce2c-1475-4383-ad64-915702d87cf4/async_admm_distributed.png)

### Key Observations
1.  **Cost Efficiency (Middle Graph)**:
    - **Proposed (Blue)**: Cost drops to near zero (~0.07).
    - **Standard (Red)**: Cost stays high (~14.5).
    - **Analysis**: This is the "Aha!" moment. In a distributed setting with delays, Standard ADMM forces agents to agree on "average" positions that might be energy-inefficient zig-zags. **Adaptive ADMM relaxes the constraints**, allowing agents to smooth out their trajectories (lower $u^2$ energy) instead of frantically chasing noisy neighbors.

2.  **Primal Residual (Left Graph)**:
    - Both converge similarly (~60-66). This "steady state error" is the price of constant delays in a dynamic formation.

3.  **Dual Residual (Stability)**:
    - Standard ADMM drives dual residual to 0 faster (rigidity).
    - Adaptive ADMM maintains some fluctuation (flexibility).

4.  **Formation (Right Graph)**:
    - Perfect Hexagon formation achieved.

## Code Availability
- **Source Code**: [async_admm_paper.py](file:///home/sriv/async_admm_paper.py) (Rewrite)
- **Demo Script**: [demo_async_paper.py](file:///home/sriv/demo_async_paper.py)
